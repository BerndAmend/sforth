"use strict";
/**
The MIT License (MIT)

Copyright (c) 2013-2016 Bernd Amend <bernd.amend+sforth@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

forth.forthClone = function(other) {
	return JSON.parse(JSON.stringify(other));
};

forth.compiler_message_handler = forth.compiler_message_handler || console.log;

// We don't allow . in function names
// if you use $ ensure that you don't write one of the following strings
forth.mangling = {
	"\u20ac": "$$euro",
	"=": "$$eq",
	">": "$$greater",
	"<": "$$less",
	"+": "$$plus",
	"-": "$$minus",
	"*": "$$times",
	"/": "$$div",
	"!": "$$bang",
	"@": "$$at",
	"#": "$$hash",
	"%": "$$percent",
	"^": "$$up",
	"&": "$$amp",
	"~": "$$tilde",
	"?": "$$qmark",
	"|": "$$bar",
	"\\": "$$bslash",
	":": "$$colon",
	";": "$$semicolon",
	",": "$$comma",
	"[": "$$obracket",
	"]": "$$cbracket",
	"(": "$$oparentheses",
	")": "$$cparentheses",
	"{": "$$obraces",
	"}": "$$obraces",
	"\u00b7": "$$middot",
	"\"": "$$quotationmark",
	"'": "$$apostrophe",
	"Â°": "$$degree"
};

forth.mangleName = function(str) {
	let result = str;

	if(Number.isNumeric(str.charAt(0))) {
		result = "$$" + result;
	}

	for(let s in forth.mangling) {
		if (forth.mangling.hasOwnProperty(s)) {
			result = result.replaceAll(s, forth.mangling[s]);
		}
	}

	if(result[0] == ".")
		result = "$$dot" + result.substr(1);
	if(result[result.length-1] == ".")
		result = "$$dot" + result.substr(0, result.length-1);

	return result;
};

forth.demangleName = function (str) {
	let result = str;
	for(let s in forth.mangling) {
		if (forth.mangling.hasOwnProperty(s)) {
			result = result.replaceAll(forth.mangling[s], s);
		}
	}
	return result;
};

forth.Types = {
	BeginAgain: "BeginAgain",
	BeginUntil: "BeginUntil",
	BeginWhileRepeat: "BeginWhileRepeat",
	BranchCase: "BranchCase",
	BranchCaseOf: "BranchCaseOf",
	BranchIf: "BranchIf",
	BranchIfBody: "BranchIfBody",
	Body: "Body",
	Call: "Call",
	CommentLine: "CommentLine",
	CommentParentheses: "CommentParentheses",
	DoLoop: "DoLoop",
	FunctionForth: "FunctionForth",
	FunctionForthAnonymous: "FunctionForthAnonymous",
	FunctionJs: "FunctionJs",
	FunctionJsAnonymous: "FunctionJsAnonymous",
	JsCode: "JsCode",
	JsCodeDirect: "JsCodeDirect",
	JsCodeWithReturn: "JsCodeWithReturn",
	Macro: "Macro",
	Number: "Number",
	String: "String",
	TryCatchFinally: "TryCatchFinally",
	ValueLocal: "ValueLocal",
	ValueLocalTemp: "ValueLocalTemp",
	ValueToStack: "ValueToStack",

	// elements generated by the optimizer

	// the following elements add the element value to the JsCodeWithReturn object instances
	JsCodeWithReturnToVar: "JsCodeWithReturnToVar",
	JsCodeWithReturnToVarTemp: "JsCodeWithReturnToVarTemp",
	JsCodeWithReturnAssignToVar: "JsCodeWithReturnAssignToVar",
	JsCodeWithReturnAddToVar: "JsCodeWithReturnAddToVar",

	// new element name
	NumberToVar: "NumberToVar",
	NumberToVarTemp: "NumberToVarTemp",
	NumberAssignToVar: "NumberAssignToVar",
	NumberAddToVar: "NumberAddToVar",
	StringToVar: "StringToVar",
	StringToVarTemp: "StringToVarTemp",
	StringAssignToVar: "StringAssignToVar",
	StringAddToVar: "StringAddToVar",

	Empty: "Empty"
};

forth.BeginAgain = function(body) {
	this.type = forth.Types.BeginAgain;
	this.body = body;
};

forth.BeginUntil = function(body) {
	this.type = forth.Types.BeginUntil;
	this.body = body;
};

forth.BeginWhileRepeat = function(condition, body) {
	this.type = forth.Types.BeginWhileRepeat;
	this.condition = condition;
	this.body = body;
};

forth.BranchCase = function(body, defaultOf) {
	this.type = forth.Types.BranchCase;
	this.body = body;
	this.defaultOf = defaultOf;
};

forth.BranchCaseOf = function(condition, body) {
	this.type = forth.Types.BranchCaseOf;
	this.condition = condition;
	this.body = body;
};

forth.BranchIfBody = function(condition, body) {
	this.type = forth.Types.BranchIfBody;
	this.condition = condition;
	this.body = body;
};

forth.BranchIf = function(if_body, else_if_bodies, else_body) {
	this.type = forth.Types.BranchIf;
	this.if_body = if_body;
	this.else_if_bodies = else_if_bodies;
	this.else_body = else_body;
};

forth.Body = function() {
	this.type = forth.Types.Body;
	this.body = [];
};

forth.Call = function(name, argument_count, drop_result) {
	this.type = forth.Types.Call;
	this.name = name;
	this.argument_count = argument_count; // optional, specifies how many arguments should be passed to a js function
	this.drop_result = drop_result; // optional
};

forth.CommentLine = function(comment) {
	this.type = forth.Types.CommentLine;
	this.comment = comment;
};

forth.CommentParentheses = function(comment) {
	this.type = forth.Types.CommentParentheses;
	this.comment = comment;
};

forth.DoLoop = function(index, body, compareOperation) {
	this.type = forth.Types.DoLoop;
	this.index = index;
	this.compareOperation = compareOperation;
	this.increment = null;
	this.body = body;
};

forth.FunctionForth = function(name, body) {
	this.type = forth.Types.FunctionForth;
	this.name = name;
	this.body = body;
};

forth.FunctionForthAnonymous = function(body) {
	this.type = forth.Types.FunctionForthAnonymous;
	this.body = body;
};

forth.FunctionJs = function(name, args, body, returnValue) {
	this.type = forth.Types.FunctionJs;
	this.name = name;
	this.args = args;
	this.body = body;
};

forth.FunctionJsAnonymous = function(args, body, returnValue) {
	this.type = forth.Types.FunctionJsAnonymous;
	this.args = args;
	this.body = body;
};

forth.JsCode = function(body) {
	this.type = forth.Types.JsCode;
	this.body = body;
};

forth.JsCodeDirect = function(body) {
	this.type = forth.Types.JsCodeDirect;
	this.body = body;
};

forth.JsCodeWithReturn = function(body) {
	this.type = forth.Types.JsCodeWithReturn;
	this.body = body;
};

forth.Macro = function(name, args, body) {
	this.type = forth.Types.Macro;
	this.name = name;
	this.args = args;
	this.body = body;
 };

forth.Number = function(value) {
	this.type = forth.Types.Number;
	this.value = value;
};

forth.String = function(value) {
	this.type = forth.Types.String;
	this.value = value;
};

forth.TryCatchFinally = function(body, catchVar, catchBody, finallyBody) {
	this.type = forth.Types.TryCatchFinally;
	this.body = body;
	this.catchVar = catchVar;
	this.catchBody = catchBody;
	this.finallyBody = finallyBody;
};

forth.ValueLocalTemp = function(values, comment) {
	this.type = forth.Types.ValueLocalTemp;
	this.values = values;
	this.comment = comment;
};

forth.ValueLocal = function(values, comment) {
	this.type = forth.Types.ValueLocal;
	this.values = values;
	this.comment = comment;
};

forth.ValueToStack = function(name) {
	this.type = forth.Types.ValueToStack;
	this.name = name;
};

// Currently this function only splits the code into tokens
// later version will also keep track where the tokens are fetched from
forth.tokenize = function(code) {
	// unify line endings
	let clean_code = code.replace(/\r\n/gm, '\n')
		.replace(/\n/gm, ' \n ')
		.replace(/\t/gm, ' \t ')
		.replace(/\r/gm, ' \n ');

	// tokenize code
	let tokens=clean_code.split(" ");

	// merge tokens
	let merged_tokens = [];

	function add(something) {
		merged_tokens.push(something);
	}

	var str;
	let depth;

	for( let i = 0 ; i < tokens.length; i++ ) {
		let t = tokens[i];
		str = "";
		depth = 1;

		switch (t.toLowerCase()) {
			case "": // ignore empty/whitespace tokens
			case "\n":
			case "\t":
			case "\r":
				break;

			case "\\\\":
				i++;
				while(i < tokens.length) {
					str += tokens[i] + " ";
					i++;
				}
				add(new forth.CommentParentheses(str.slice(0, str.length-1)));
				break;

			case "\\": // line comments
			case "//":
				while(tokens[i] != "\n") {
					i++;

					if(i >= tokens.length)
						break;

					if(tokens[i] != "\n")
						str += tokens[i] + " ";
				}
				add(new forth.CommentLine(str.slice(0,str.length-1)));
				break;
			case "(": // comment start
				while(depth > 0) {
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find closing ')'");

					if(tokens[i] == "(")
						depth++;
					else if(tokens[i] == ")") {
						depth--;
					}

					if(depth > 0)
						str += tokens[i] + " ";
				}
				add(new forth.CommentParentheses(str.slice(0, str.length-1)));
				break;
			case "/*": // comment start
			case "/**":
				while(depth > 0) {
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find closing '*/'");

					if(tokens[i] == "/*" || tokens[i] == "/**")
						depth++;
					else if(tokens[i] == "*/") {
						depth--;
					}

					if(depth > 0)
						str += tokens[i] + " ";
				}
				add(new forth.CommentParentheses(str.slice(0, str.length-1)));
				break;
			case ":[": // execute js code start
				i++;
				while(tokens[i] != "]:" && tokens[i] != "]:d" && tokens[i] != "];") {
					str += tokens[i] + " ";
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find closing ']:' or ']:d' or '];' for ':[");
				}
				var localjscode = str.slice(0,str.length-1).replace(/ \t /gm, '\t');
				if(tokens[i] == "]:")
					add(new forth.JsCodeWithReturn(localjscode));
				else if(tokens[i] == "]:d")
					add(new forth.JsCodeDirect(localjscode));
				else //if(tokens[i] == "];")
					add(new forth.JsCode(localjscode));
				break;
			case "{": // local variable start
			case "local{": // local variable start
				var start = tokens[i];
				var done = false;
				var localvars = [];
				var comment = "";
				i++;
				while(tokens[i] != "}") {
					if(tokens[i] == "--") {
						done = true;
						i++;
						continue;
					}
					if(!done) {
						localvars.push(tokens[i]);
					} else {
						comment += tokens[i] + " ";
					}
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find closing '}' for '"+start+"'");
				}
				switch(start) {
					case "{":
						add(new forth.ValueLocal(localvars.reverse(), comment.slice(0, comment.length-1)));
						break;
					case "local{":
						add(new forth.ValueLocalTemp(localvars.reverse(), comment.slice(0, comment.length-1)));
						break;
				}
				break;
			case "{}":
				add(new forth.ValueLocal([], ""));
				break;
			default:
				var replacedcommawithperiod = t.replaceAll(",", ".");
				if(Number.isNumeric(replacedcommawithperiod)) {
					add(new forth.Number(replacedcommawithperiod));
				} else if(t[0] == "'" && t.length == 2) {
					add(new forth.Number(t.charCodeAt(1)));
				} else if(t[0] == "\"") {
					var escapecounter = 0;
					var j=0;
					var str = "";
					while(true) {
						if(tokens[i].length-1==j || tokens[i].length == 0) {
							j=0;
							i++;
							if(i >= tokens.length)
								throw new Error("Couldn't find '\"'");
							str += " ";
							if(tokens[i].length == 0)
								continue;
						} else {
							j++;
						}

						if(tokens[i][j] == "\\") {
							escapecounter++;
						} else {
							for(var k=0;k<escapecounter;k++)
								str += "\\";
							if(escapecounter % 2 == 0 && tokens[i][j] == "\"")
								break;
							escapecounter=0;
							str += tokens[i][j];
						}
					}

					add(new forth.String(str.slice(0,str.length)
											.replace(/ \n /gm, '\\n')
											.replace(/ \t /gm, '\\t')
											.replace(/ \r /gm, '\\r')
						));
				} else if(t[0] == "\u00bb") { // Â»
					if(tokens[i].substr(tokens[i].length-1) == "\u00ab" && // Â«
						tokens[i].substr(tokens[i].length-2) != "\\\u00ab" // Â«
					) {
						str = tokens[i].substr(1,tokens[i].length-1);
					} else {
						str = tokens[i].substr(1) + " ";
						i++;
						while(true) {
							if(tokens[i].substr(tokens[i].length-1) == "\u00ab" && // Â«
								tokens[i].substr(tokens[i].length-2) != "\\\u00ab" // Â«
							) {
								if(tokens[i].length == 1)
									str += " ";
								else
									str += tokens[i];
								break;
							} else {
								str += tokens[i] + " ";
							}
							i++;

							if(i >= tokens.length)
								throw new Error("Couldn't find closing '\u00ab' for '\u00bb'");
						}
					}
					add(new forth.String(str.slice(0,str.length-1)
											.replace(/ \n /gm, '\\n')
											.replace(/ \t /gm, '\\t')
											.replace(/ \r /gm, '\\r')
											.replaceAll("\"", "\\\"")
											.replaceAll("\\\u00bb", "\u00bb")
											.replaceAll("\\\u00ab", "\u00ab")
						));
				} else if(t[0] == "$" && t.length >= 2) { // handle hex numbers
					add(new forth.Number("0x" + t.substr(1)));
				} else if(t[0] == "%" && t.length >= 2) { // handle binary numbers
					add(new forth.Number(parseInt(t.substr(1),2)));
				} else {
					add(t);
				}
		}
	}

	return merged_tokens;
};

forth.createFromForthTokens = function(tokens, context) {
	context = context || {}; //forth.forthClone(parent_context);

	let out = new forth.Body();

	function add(something) {
		out.body.push(something);
	}

	let current;
	let depth;
	let localtree;
	let args;
	let function_name;
	let returnValue;
	let token_handled;
	let values;

	for( let i = 0 ; i < tokens.length; i++ ) {
		let t = tokens[i];

		depth = 1;
		current = [];
		localtree = null;
		args = null;
		function_name = null;
		returnValue = false;
		values = null;

		token_handled = false;

		switch(t.type) {
			case forth.Types.CommentLine:
			case forth.Types.CommentParentheses:
			case forth.Types.JsCodeWithReturn:
			case forth.Types.JsCodeDirect:
			case forth.Types.JsCode:
			case forth.Types.ValueLocal:
			case forth.Types.ValueLocalTemp:
			case forth.Types.Number:
			case forth.Types.String:
				add(t);
				token_handled = true;
				break;
		}

		if(token_handled)
			continue;

		switch (t.toLowerCase()) {
			case "if":
				var tokensIf = current;
				var tokensElseIf = null;
				var tokensElse = null;

				while(depth > 0) {
					i++;

					if(i >= tokens.length) {
						forth.compiler_message_handler("tokens=" + JSON.stringify(tokens));
						throw new Error("Couldn't find closing 'endif/then' for 'if'");
					}

					if(tokens[i].type) {
						current.push(tokens[i]);
						continue;
					}

					switch(tokens[i].toLowerCase()) {
						case "if":
							depth++;
							current.push(tokens[i]);
							break;
						case "elseif":
							if(depth == 1) {
								if(!tokensElseIf)
									tokensElseIf = [];

								var elseIf = new forth.BranchIfBody([], []);
								tokensElseIf.push(elseIf);

								current = elseIf.condition;
								// scan for the next if
								while(true) {
									i++;
									if(i >= tokens.length) {
										forth.compiler_message_handler("tokens=" + JSON.stringify(tokens));
										throw new Error("Couldn't find closing 'if' for 'elseif'");
									}
									if(!tokens[i].type && tokens[i].toLowerCase() == "if")
										break;

									current.push(tokens[i]);
								}

								current = elseIf.body;
								//forth.compiler_message_handler("current=" + JSON.stringify(elseIf));
							} else {
								current.push(tokens[i]);
							}
							break;
						case "else":
							if(depth == 1) {
								tokensElse = [];
								current = tokensElse;
							} else {
								current.push(tokens[i]);
							}
							break;
						case "then":
						case "endif":
							depth--;
							if(depth > 0)
								current.push(tokens[i]);
							break;
						default:
							current.push(tokens[i]);
					}
				}

				let compiledIf = null;
				let compiledElseIf = null;
				let compiledElse = null;

				if(tokensIf)
					compiledIf = forth.createFromForthTokens(tokensIf, context);

				if(tokensElseIf) {
					/*jshint loopfunc:true */
					compiledElseIf = [];
					tokensElseIf.forEach(function(entry) {
						let condition = forth.createFromForthTokens(entry.condition, context);
						let body = forth.createFromForthTokens(entry.body, context);
						compiledElseIf.push(new forth.BranchIfBody(condition, body));
					});
				}

				if(tokensElse)
					compiledElse = forth.createFromForthTokens(tokensElse, context);

				add(new forth.BranchIf(compiledIf, compiledElseIf, compiledElse));
				break;
			case "try":
				let tokensBody = current;
				let tokensCatch = null;
				let tokensFinally = null;

				let catchVar = null;

				while(depth > 0) {
					i++;

					if(i >= tokens.length) {
						forth.compiler_message_handler("tokens=" + JSON.stringify(tokens));
						throw new Error("Couldn't find 'endtry' for 'try'");
					}

					if(tokens[i].type) {
						current.push(tokens[i]);
						continue;
					}

					switch(tokens[i].toLowerCase()) {
						case "try":
							depth++;
							current.push(tokens[i]);
							break;
						case "catch":
							if(depth == 1) {
								i++;
								catchVar = tokens[i];
								tokensCatch = [];
								current = tokensCatch;
							} else {
								current.push(tokens[i]);
							}
							break;
						case "finally":
							if(depth == 1) {
								tokensFinally = [];
								current = tokensFinally;
							} else {
								current.push(tokens[i]);
							}
							break;
						case "endtry":
							depth--;
							if(depth > 0)
								current.push(tokens[i]);
							break;
						default:
							current.push(tokens[i]);
					}
				}

				var compiledBody = null;
				var compiledCatch = null;
				var compiledFinally = null;

				if(tokensBody)
					compiledBody = forth.createFromForthTokens(tokensBody, context);

				if(tokensCatch)
					compiledCatch = forth.createFromForthTokens(tokensCatch, context);

				if(tokensFinally)
					compiledFinally = forth.createFromForthTokens(tokensFinally, context);

				add(new forth.TryCatchFinally(compiledBody, catchVar, compiledCatch, compiledFinally));
				break;
			case "begin":
				while(depth > 0) {
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find closing 'again/until' for 'begin'");

					if(tokens[i].type) {
						current.push(tokens[i]);
						continue;
					}

					switch(tokens[i].toLowerCase()) {
						case "begin":
							depth++;
							current.push(tokens[i]);
							break;
						case "until":
						case "again":
							depth--;
							if(depth > 0)
								current.push(tokens[i]);
							break;
						default:
							current.push(tokens[i]);
					}
				}

				var ltoken = tokens[i].toLowerCase();
				if(ltoken.toLowerCase() == "until")
					add(new forth.BeginUntil(forth.createFromForthTokens(current, context)));
				else if(ltoken == "again")
					add(new forth.BeginAgain(forth.createFromForthTokens(current, context)));
				else
					throw new Error("Internal compiler error: last closing element in a begin loop was invalid");
				break;
			case "case":
				// TODO: we have to parse the of entries
				let defaultOf = null;
				while(depth > 0) {
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find closing 'endcase' for 'case'");

					if(tokens[i].type) {
						current.push(tokens[i]);
						continue;
					}

					switch(tokens[i].toLowerCase()) {
						case "case":
							depth++;
							current.push(tokens[i]);
							break;
						case "endcase":
							depth--;
							if(depth > 0)
								current.push(tokens[i]);
							break;
						default:
							current.push(tokens[i]);
					}
				}

				// parse of endof

				add(new forth.BranchCase(forth.createFromForthTokens(current, context), defaultOf));
				break;
			case "do":
			case "+do":
			case "-do":
				let starti = i;
				let start = tokens[i];

				i++;

				if(i >= tokens.length)
						throw new Error("Couldn't find closing element for '" + start + "'");

				var idx = tokens[i];

				while(depth > 0) {
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find closing element for '" + start + "'");

					if(tokens[i].type) {
						current.push(tokens[i]);
						continue;
					}

					switch(tokens[i].toLowerCase()) {
						case "do":
						case "+do":
						case "-do":
							depth++;
							current.push(tokens[i]);
							break;
						case "loop":
							depth--;
							if(depth > 0)
								current.push(tokens[i]);
							break;
						default:
							current.push(tokens[i]);
					}
				}

				if(tokens[i].toLowerCase() != "loop") {
					throw new Error("Internal compiler error: last closing element in a '" + start + "' loop was invalid");
				}
				switch(start.toLowerCase()) {
					case "do":
						add(new forth.DoLoop(idx, forth.createFromForthTokens(current, context), null));
						break;
					case "+do":
						add(new forth.DoLoop(idx, forth.createFromForthTokens(current, context), "<"));
						break;
					case "-do":
						add(new forth.DoLoop(idx, forth.createFromForthTokens(current, context), ">"));
						break;
					default:
						throw new Error("Internal compiler error: start element in a '" + start + "' loop was invalid");
				}
				break;
			case "include":
				if(typeof Filesystem != "undefined") {
					var str = "";
					i++;

					if(i >= tokens.length)
						throw new Error("Couldn't find requirement argument for 'include'");
					if(tokens[i].type == forth.Types.String) {
						add(forth.createFromForth(Filesystem.readFileSync(tokens[i].value).toString(), context));
					} else {
						add(forth.createFromForth(Filesystem.readFileSync(tokens[i]).toString(), context));
					}
				} else {
					throw new Error("Include is not available e.g. if used inside a web browser");
				}
				break;

			case ":": // function definition
				i++;

				if(i >= tokens.length)
					throw new Error("Couldn't find closing ';' for ':'");

				function_name = tokens[i];

				while(depth > 0) {
					i++;
					if(tokens[i] == ":" || tokens[i] == ":noname" || tokens[i] == ":js" || tokens[i] == ":jsnoname") {
						depth++;
					} else if(tokens[i] == ";" || tokens[i] == "return;") {
						depth--;
					}
					if(depth > 0)
						current.push(tokens[i]);

					if(i >= tokens.length)
						throw new Error("Couldn't find closing ';' for ':'");
				}

				add(new forth.FunctionForth(function_name, forth.createFromForthTokens(current, context)));
				break;
			case ":noname": // function definition
				while(depth > 0) {
					i++;
					if(tokens[i] == ":" || tokens[i] == ":noname" || tokens[i] == ":js" || tokens[i] == ":jsnoname") {
						depth++;
					} else if(tokens[i] == ";" || tokens[i] == "return;") {
						depth--;
					}
					if(depth > 0)
						current.push(tokens[i]);

					if(i >= tokens.length)
						throw new Error("Couldn't find closing ';' for ':noname'");
				}

				add(new forth.FunctionForthAnonymous(forth.createFromForthTokens(current, context)));
				break;
			case ":js": // function definition
				i++;
				if(i >= tokens.length)
					throw new Error("Couldn't find closing ';/return;' for ':js'");

				function_name = tokens[i];

				while(depth > 0) {
					i++;
					if(tokens[i] == ":" || tokens[i] == ":noname" || tokens[i] == ":js" || tokens[i] == ":jsnoname") {
						depth++;
					} else if(tokens[i] == ";" || tokens[i] == "return;") {
						depth--;
					}
					if(depth > 0)
						current.push(tokens[i]);

					if(i >= tokens.length)
						throw new Error("Couldn't find closing ';/return;' for ':js'");
				}

				localtree = forth.createFromForthTokens(current, context);

				if(localtree.body.length > 0) {
					values = localtree.body[0];
					if(values.type !== forth.Types.ValueLocal)
						throw new Error(":js requires { <args> -- <comment> } after the function name");

					values.type = forth.Types.CommentParentheses;
					args = values.values.reverse();
				}

				if(tokens[i] == "return;") {
					localtree.body.push(new forth.JsCode("return stack.pop()"));
				}

				add(new forth.FunctionJs(function_name, args, localtree, returnValue));
				break;
			case ":jsnoname": // function definition
				while(depth > 0) {
					i++;
					if(tokens[i] == ":" || tokens[i] == ":noname" || tokens[i] == ":js" || tokens[i] == ":jsnoname") {
						depth++;
					} else if(tokens[i] == ";" || tokens[i] == "return;") {
						depth--;
					}
					if(depth > 0)
						current.push(tokens[i]);

					if(i >= tokens.length)
						throw new Error("Couldn't find closing ';/return;' for ':jsnoname'");
				}

				localtree = forth.createFromForthTokens(current, context);

				if(localtree.body.length > 0) {
					values = localtree.body[0];
					if(values.type != forth.Types.ValueLocal)
						throw new Error(":jsnoname requires { <args> -- <comment> } after :jsnoname");

					values.type = forth.Types.CommentParentheses;
					args = values.values.reverse();
				}

				if(tokens[i] == "return;") {
					localtree.body.push(new forth.JsCode("return stack.pop()"));
				}

				add(new forth.FunctionJsAnonymous(args, localtree, returnValue));
				break;

			case ":macro": // macro definition
				i++;

				if(i >= tokens.length)
					throw new Error("Couldn't find closing ';' for ':'");

				function_name = tokens[i];

				while(depth > 0) {
					i++;
					if(tokens[i] == ":macro" || tokens[i] == ":" || tokens[i] == ":noname" || tokens[i] == ":js" || tokens[i] == ":jsnoname") {
						depth++;
					} else if(tokens[i] == ";" || tokens[i] == "return;") {
						depth--;
					}
					if(depth > 0)
						current.push(tokens[i]);

					if(i >= tokens.length)
						throw new Error("Couldn't find closing ';' for ':'");
				}

				args = current.splice(0,1)[0];

				if(args.type != forth.Types.ValueLocal)
					throw new Error(t + " " + function_name + " requires { .. } after the macro name");

				var macro = new forth.Macro(function_name, args.values, current);
				add(macro);

				if(!context.macro)
					context.macro = {};

				context.macro[forth.mangleName(function_name)] = macro;
				break;

			// forbidden tokens
			case ")": // comment end
			case "]:": // execute js code end
			case "]:d": // execute js code end
			case "else":
			case "then":
			case "endif":
			case "endcase":
			case ";":
			case "return;":
			case "}": // local variable end
				forth.compiler_message_handler("Unexpected token " + t + " found");
				break;
			default:
				var mangledT = forth.mangleName(t);
				var dmacro = null;
				// TODO: resolve macro
				// first try to find the macro within the current list
				if(context.macro && context.macro[mangledT]) {
					dmacro = context.macro[mangledT];
				} else if(forth.macros && forth.macros[mangledT]) {
					// search within the global list
					dmacro = forth.macros[mangledT];
				}

				if(dmacro) {
					var gcode = null;
					if(dmacro.args.length === 0) {
						gcode = forth.createFromForthTokens(dmacro.body, context);
						add(gcode);
					} else {
						gcode = forth.forthClone(dmacro.body);
						for(var k=dmacro.args.length-1;k>=0;--k) {
							i++;
							for(var n=0; n<gcode.length;++n) {
								var entry = gcode[n];
								if(typeof entry.type != "undefined") {
									switch(entry.type) {
										case forth.Types.JsCodeDirect:
										case forth.Types.JsCode:
										case forth.Types.JsCodeWithReturn:
											if(typeof tokens[i] == "undefined") {
												forth.compiler_message_handler("Can not find required macro argument for " + dmacro.name);
											}
											if(typeof tokens[i].type != "undefined") {
												switch(tokens[i].type) {
													case forth.Types.Number:
														entry.body = entry.body.replaceWholeWord(dmacro.args[k], tokens[i].value);
														break;
													case forth.Types.String:
														entry.body = entry.body.replaceWholeWord(dmacro.args[k], "\"" + tokens[i].value + "\"");
														break;
													default:
														throw new Error("I don't know what I should do with " + JSON.stringify(tokens[i]) + " as a macro argument");
												}
											} else {
												// TODO: mangeling should only be done in the generateJsCode function
												entry.body = entry.body.replaceWholeWord(dmacro.args[k], forth.mangleName(tokens[i])).replaceAll("#" + dmacro.args[k], forth.mangleName(tokens[i]));
											}
											break;
									}
								} else {
									if(entry == dmacro.args[k]) {
										gcode[n] = tokens[i];
									} else if(entry == ("#" + dmacro.args[k])) {
										gcode[n] = new forth.String(tokens[i]);
									}
								}
							}
						}

						var cgcode = forth.createFromForthTokens(gcode, context);
						cgcode.extendedMacro=t;
						add(cgcode);
					}
				} else {
					var match = /^(.+)\((\d*)\)$/.exec(t);
					if(match === null) {
						var match = /^(.+)\((\d*)\);$/.exec(t);
						if(match === null) {
							add(new forth.Call(t));
						} else {
							add(new forth.Call(match[1], match[2], true));
						}
					} else {
						add(new forth.Call(match[1], match[2]));
					}
				}
		}
	}

	return out;
};

forth.createFromForth = function(code, context) {
	return forth.createFromForthTokens(forth.tokenize(code), context);
};

forth.generateJsCode = function(code_tree, indent_characters) {
	if(indent_characters === undefined)
		indent_characters = "\t";

	function generateCode(code_tree, level) {

		let out = "";

		var lp =  "";
		for(var i = 0; i < level; i++)
			lp += indent_characters;

		function append(str, add_level) {
			if(add_level === undefined)
				add_level = 0;
			var tlp = lp;
			for(var i = 0; i < add_level; i++)
			tlp += indent_characters;
			if(str && str !== "")
				out += tlp + str + "\n";
		}

		var name = null;
		var clean = null;
		var args = null;

		switch(code_tree.type) {
			case forth.Types.Empty:
				break;
			case forth.Types.BeginAgain:
				append("do {");
				out += generateCode(code_tree.body, level);
				append("} while(true);");
				break;
			case forth.Types.BeginUntil:
				append("do {");
				out += generateCode(code_tree.body, level);
				append("} while(!stack.pop());");
				break;
			case forth.Types.BeginWhileRepeat:
				append("do {");
				out += generateCode(code_tree.condition, level);
				append("if(!stack.pop()) break;");
				out += generateCode(code_tree.body, level);
				append("} while(true);");
				break;
			case forth.Types.BranchCase:
				append("switch(stack.pop()) {");
				//code_tree.body.forEach(function(entry) {
				//	out += generateCode(entry, level+1);
				//});
				out += generateCode(code_tree.body, level+1);
				if(code_tree.defaultOf) {
					append("default:");
					out += generateCode(code_tree.defaultOf, level);
				}
				append("}");
				break;
			case forth.Types.BranchCaseOf:
				append("case " + code_tree.condition + ":");
				out += generateCode(code_tree.body, level+1);
				append("break;");
				break;
			case forth.Types.BranchIf:
				var openingBrackets = 0;
				var identLevel = "";
				append("if(stack.pop()) {");
				out += generateCode(code_tree.if_body, level);
				if(code_tree.else_if_bodies) {
					code_tree.else_if_bodies.forEach(function(entry) {
						append(identLevel + "} else {");
						identLevel += indent_characters;
						out += generateCode(entry.condition, level+openingBrackets);
						append(identLevel + "if(stack.pop()) {");
						out += generateCode(entry.body, level+openingBrackets+1);
						openingBrackets++;
					});
				}
				if(code_tree.else_body) {
					append(identLevel + "} else {");
					out += generateCode(code_tree.else_body, level+openingBrackets);
				}
				for(var j=0;j<openingBrackets+1;++j) {
					append(identLevel + "}");
					identLevel = identLevel.substr(0,identLevel.length-1);
				}
				break;
			case forth.Types.Body:
				code_tree.body.forEach(function(entry) {
					var l = level;
					if(!entry.extendedMacro)
						l++;
					out += generateCode(entry, l);
				});
				break;

			case forth.Types.Call:
				name = forth.mangleName(code_tree.name);
				var splitted = name.split(".");
				var ctxt = splitted.slice(0, splitted.length-1).join(".");
				if(ctxt === "")
					ctxt = "this";
				if(code_tree.argument_count === undefined) {
					append("if(typeof " + name + " == 'function') {");
					append("if(!" + name + ".forth_function) { stack.pushIfNotUndefined(" + name + ".apply(" + ctxt + ", stack.getTopElements(" + name + ".length)));");
					append("} else { " + name + "(stack); }");
					append("} else { stack.push(" + name + ");}");
				} else if(code_tree.drop_result === undefined) {
					if(code_tree.argument_count === "") {
						append("if(!" + name + ".forth_function) { stack.pushIfNotUndefined(" + name + ".apply(" + ctxt + ", stack.getTopElements(" + name + ".length)));");
						append("} else { " + name + "(stack); }");
					} else if(code_tree.argument_count === 0) {
						append("stack.pushIfNotUndefined(" + name + "());");
					} else {
						append("stack.pushIfNotUndefined(" + name + ".apply(" + ctxt + ", stack.getTopElements(" + code_tree.argument_count + ")));");
					}
				} else {
					if(code_tree.argument_count === "") {
						append("if(!" + name + ".forth_function) { " + name + ".apply(" + ctxt + ", stack.getTopElements(" + name + ".length));");
						append("} else { " + name + "(stack); }");
					} else if(code_tree.argument_count === 0) {
						append(name + "();");
					} else {
						append(name + ".apply(" + ctxt + ", stack.getTopElements(" + code_tree.argument_count + "));");
					}
				}

				break;

			// we ignore CommentLines and CommentParentheses
			case forth.Types.CommentLine:
			case forth.Types.CommentParentheses:
				break;

			case forth.Types.DoLoop:
				var idx = forth.mangleName(code_tree.index);

				if(code_tree.increment === null) {
					if(code_tree.compareOperation === null) {
						throw new Error("Can not deduce in which direction the loop should go either use +do, -do, or use a constant increment");
					}

					append("var " + idx + "_increment=stack.pop();");
					append("var " + idx + "_end=stack.pop();");

					append("for(var " + idx + "=stack.pop(); " + idx + code_tree.compareOperation + idx + "_end;" + idx + "+= " + idx + "_increment) {");
						out += generateCode(code_tree.body, level);
					append("}");
				} else {
					append("var " + idx + "_end=stack.pop();");

					if(code_tree.increment == 1) {
						append("for(var " + idx + "=stack.pop(); " + idx + "<" + idx + "_end; ++" + idx + ") {");
					} else if(code_tree.increment == -1) {
						append("for(var " + idx + "=stack.pop(); " + idx + ">" + idx + "_end; --" + idx + ") {");
					} else {
						if(code_tree.increment >= 0) {
							append("for(var " + idx + "=stack.pop(); " + idx + "<" + idx + "_end;" + idx + "+= " + code_tree.increment + ") {");
						} else {
							append("for(var " + idx + "=stack.pop(); " + idx + ">" + idx + "_end;" + idx + "+= " + code_tree.increment + ") {");
						}
					}
						out += generateCode(code_tree.body, level);
					append("}");
				}

				break;

			case forth.Types.FunctionForth:
				name = forth.mangleName(code_tree.name);
				if(name.indexOf(".") != -1)
					throw new Error("Function names can not contain .");
				append("function " + name + "(stack) {");
				append("'use strict';");
				append("/* jshint validthis:true */");
				out += generateCode(code_tree.body, level);
				append("}");
				append(name + ".forth_function=true;\n");
				break;
			case forth.Types.FunctionForthAnonymous:
				append("stack.push(function(stack) {");
				append("'use strict';");
				append("/* jshint validthis:true */");
				out += generateCode(code_tree.body, level);
				append("});\n");
				append("stack.top().forth_function=true;");
				break;

			case forth.Types.FunctionJs:
				name = forth.mangleName(code_tree.name);
				if(name.indexOf(".") != -1)
					throw new Error("Function names can not contain .");
				args = code_tree.args.map(forth.mangleName).join(", ");
				append("function " + name + "(" + args + ") {");
				append("'use strict';");
				append("/* jshint validthis:true */");
				append(indent_characters + "var stack = new forth.Stack();");
				out += generateCode(code_tree.body, level);
				append("}");
				break;
			case forth.Types.FunctionJsAnonymous:
				args = code_tree.args.map(forth.mangleName).join(", ");
				append("stack.push(function(" + args + ") {");
				append("'use strict';");
				append("/* jshint validthis:true */");
				append(indent_characters + "var stack = new forth.Stack();");
				out += generateCode(code_tree.body, level);
				append("});");
				break;

			case forth.Types.JsCode:
				clean = code_tree.body.replaceAll(" ", "").replaceAll("\t", "").replaceAll("\n", "").replaceAll("\r", "");
				if(clean && clean !== "")
					append(code_tree.body + ";");
				break;
			case forth.Types.JsCodeDirect:
				clean = code_tree.body.replaceAll(" ", "").replaceAll("\t", "").replaceAll("\n", "").replaceAll("\r", "");
				if(clean && clean !== "")
					append(code_tree.body);
				break;
			case forth.Types.JsCodeWithReturn:
				append("stack.push(" + code_tree.body + ");");
				break;

			case forth.Types.JsCodeWithReturnToVar:
			case forth.Types.JsCodeWithReturnToVarTemp:
				append("var " + forth.mangleName(code_tree.value) + " = " + code_tree.body + ";");
				break;
			case forth.Types.JsCodeWithReturnAssignToVar:
				append(forth.mangleName(code_tree.value) + " = " + code_tree.body + ";");
				break;
			case forth.Types.JsCodeWithReturnAddToVar:
				append(forth.mangleName(code_tree.value) + " += " + code_tree.body + ";");
				break;

			case forth.Types.Macro:
				if(code_tree.name.indexOf(".") != -1)
					throw new Error("Macros names can not contain .");

				name = forth.mangleName(code_tree.name);

				append("forth.macros." + name + " = " + JSON.stringify(code_tree) + ";\n");
				break;

			case forth.Types.Number:
				append("stack.push(" + code_tree.value + ");");
				break;
			case forth.Types.NumberToVar:
			case forth.Types.NumberToVarTemp:
				append("var " + forth.mangleName(code_tree.name) + " = " + code_tree.value + ";");
				break;
			case forth.Types.NumberAssignToVar:
				append(forth.mangleName(code_tree.name) + " = " + code_tree.value + ";");
				break;
			case forth.Types.NumberAddToVar:
				append(forth.mangleName(code_tree.name) + " += " + code_tree.value + ";");
				break;

			case forth.Types.String:
				append("stack.push(\"" + code_tree.value + "\");");
				break;
			case forth.Types.StringToVar:
			case forth.Types.StringToVarTemp:
				append("var " + forth.mangleName(code_tree.name) + " = \"" + code_tree.value + "\";");
				break;
			case forth.Types.StringAssignToVar:
				append(forth.mangleName(code_tree.name) + " = \"" + code_tree.value + "\";");
				break;
			case forth.Types.StringAddToVar:
				append(forth.mangleName(code_tree.name) + " += \"" + code_tree.value + "\";");
				break;

			case forth.Types.TryCatchFinally:
				append("try {");
					out += generateCode(code_tree.body, level+1);
				append("} catch( " + code_tree.catchVar + ") {");
					out += generateCode(code_tree.catchBody, level+1);
				if(code_tree.finallyBody) {
					append("} finally {");
					out += generateCode(code_tree.finallyBody, level+1);
				}
				append("}");
				break;
			case forth.Types.ValueLocal:
			case forth.Types.ValueLocalTemp:
				code_tree.values.forEach(function(entry) {
					var varname = forth.mangleName(entry);
					append("var " + varname + " = stack.pop();");
				});
				break;
			case forth.Types.ValueToStack:
				name = forth.mangleName(code_tree.name);
				append("stack.push(" + name + ");");
				break;
			default:
				forth.compiler_message_handler("Unknown type=" + code_tree.type);
				forth.compiler_message_handler("Unknown " + JSON.stringify(code_tree, null, "\t"));
		}

		return out;
	}

	return "\"use strict\";\n" + generateCode(code_tree, -1);
};

forth.optimizeCodeTree = function(org_code_tree) {
	var code_tree = forth.forthClone(org_code_tree);

	var modified;

	function visitNodes(func, current, previous) {
		if(current === null || current === undefined) {
		} else if(current instanceof Array) {
			return func(current, previous);
		} else {
			switch(current.type) {
				case forth.Types.Body:
					return visitNodes(func, current.body, previous);
					break;
				case forth.Types.BeginAgain:
				case forth.Types.BeginUntil:
				case forth.Types.BeginWhileRepeat:
				case forth.Types.BranchCaseOf:
				case forth.Types.BranchIfBody:
				case forth.Types.DoLoop:
				case forth.Types.FunctionForth:
				case forth.Types.FunctionForthAnonymous:
				case forth.Types.FunctionJs:
				case forth.Types.FunctionJsAnonymous:
					visitNodes(func, current.body);
					break;
				case forth.Types.BranchCase:
					visitNodes(func, current.body);
					visitNodes(func, current.defaultOf);
					break;
				case forth.Types.BranchIf:
					visitNodes(func, current.if_body);
					visitNodes(func, current.else_if_bodies);
					visitNodes(func, current.else_body);
					break;
				case forth.Types.Empty:
				case forth.Types.Call:
				case forth.Types.CommentLine:
				case forth.Types.CommentParentheses:
				case forth.Types.JsCode:
				case forth.Types.JsCodeDirect:
				case forth.Types.JsCodeWithReturn:
				case forth.Types.JsCodeWithReturnToVar:
				case forth.Types.JsCodeWithReturnToVarTemp:
				case forth.Types.JsCodeWithReturnAssignToVar:
				case forth.Types.JsCodeWithReturnAddToVar:
				case forth.Types.Macro:
				case forth.Types.Number:
				case forth.Types.NumberToVar:
				case forth.Types.NumberToVarTemp:
				case forth.Types.NumberAssignToVar:
				case forth.Types.NumberAddToVar:
				case forth.Types.String:
				case forth.Types.StringToVar:
				case forth.Types.StringToVarTemp:
				case forth.Types.StringAssignToVar:
				case forth.Types.StringAddToVar:
				case forth.Types.ValueLocal:
				case forth.Types.ValueLocalTemp:
					break;
				case forth.Types.TryCatchFinally:
					visitNodes(func, current.body);
					visitNodes(func, current.catchBody);
					visitNodes(func, current.finallyBody);
					break;
				default:
					console.log("Unexpected entry found: " + JSON.stringify(current));
			}
		}
	}

	// rewrite do without a compare operation to do with an increment
	function fixIncompleteDoLoops(current, previous) {
		for (var i=0;i<current.length;++i) {
			var val = current[i];
			if(val.type === forth.Types.DoLoop &&
				val.compareOperation === null && val.increment === null &&
				previous !== null && previous !== undefined && previous.type === forth.Types.Number) {
				modified = true;
				val.increment = previous.value;
				previous.type = forth.Types.Empty;
				return;
			}

			if(val.type == forth.Types.CommentLine || val.type == forth.Types.CommentParentheses) {
			} else if(val.type === forth.Types.Body) {
				previous = visitNodes(fixIncompleteDoLoops, val, previous);
			} else {
				visitNodes(fixIncompleteDoLoops, val);
				previous = val;
			}
		}
		return previous;
	}

	// rewrite var <something> = stack.pop() to ValueLocal
	function rewriteStackPop(current, previous) {
		for (var i=0;i<current.length;++i) {
			var val = current[i];
			if(val.type === forth.Types.JsCode) {
				var match = /^[ ]*var[ ]+(.+)[ ]+=[ ]+stack\.pop\([ ]*\)[ ;]*$/.exec(val.body);
				if(match !== null) {
					modified = true;
					val.type = forth.Types.ValueLocal;
					delete val.body;
					val.values = [match[1]];
				}
			}
			visitNodes(rewriteStackPop, val);
		}
	}

	// remove empty code tree entries
	function removeEmptyCodeTreeEntries(current) {
		for (var i=0;i<current.length;++i) {
			var val = current[i];
			if((val.type === forth.Types.ValueLocal && val.values.length === 0) ||
				(val.type === forth.Types.ValueLocalTemp && val.values.length === 0) ||
				(val.type === forth.Types.Body && val.body.length == 0) ||
				(val.type === forth.Types.Empty)
			) {
				current.splice(i, 1);
				modified = true;
			}
			visitNodes(removeEmptyCodeTreeEntries, val);
		}
	}

	function inlineValueLocal(current, previous) {
		for (var i=0;i<current.length;++i) {
			var val = current[i];
			if(previous !== null && previous !== undefined &&
				(
					(val.type === forth.Types.ValueLocal && val.values.length > 0)
				)
			) {
				if(previous.type === forth.Types.Number) {
					previous.type = forth.Types.NumberToVar;
					previous.name = val.values.splice(0, 1)[0];
					modified = true;
					return;
				} else if(previous.type === forth.Types.String) {
					previous.type = forth.Types.StringToVar;
					previous.name = val.values.splice(0, 1)[0];
					modified = true;
					return;
				} else if(previous.type === forth.Types.JsCodeWithReturn) {
					previous.type = forth.Types.JsCodeWithReturnToVar;
					previous.value = val.values.splice(0,1)[0];
					modified = true;
					return;
				}
			}
			if(val.type == forth.Types.CommentLine || val.type == forth.Types.CommentParentheses) {
			} else if(val.type === forth.Types.ValueLocal && val.values.length == 0) {
			} else if(val.type === forth.Types.ValueLocalTemp && val.values.length == 0) {
			} else if(val.type === forth.Types.NumberToVar || val.type === forth.Types.StringToVar ||
				val.type === forth.Types.JsCodeWithReturnToVar ||
				val.type === forth.Types.NumberToVarTemp || val.type === forth.Types.StringToVarTemp ||
				val.type === forth.Types.JsCodeWithReturnToVarTemp
			) {
			} else if(val.type === forth.Types.Body) {
				previous = visitNodes(inlineValueLocal, val, previous);
			} else {
				visitNodes(inlineValueLocal, val);
				previous = val;
			}
		}
		return previous;
	}

	function inlineValueLocalTemp(current, previous) {
		for (var i=0;i<current.length;++i) {
			var val = current[i];
			if(previous !== null && previous !== undefined &&
				(
					(val.type === forth.Types.ValueLocalTemp && val.values.length > 0)
				)
			) {
				if(previous.type === forth.Types.Number) {
					previous.type = forth.Types.NumberToVarTemp;
					previous.name = val.values.splice(0, 1)[0];
					modified = true;
					return;
				} else if(previous.type === forth.Types.String) {
					previous.type = forth.Types.StringToVarTemp;
					previous.name = val.values.splice(0, 1)[0];
					modified = true;
					return;
				} else if(previous.type === forth.Types.JsCodeWithReturn) {
					previous.type = forth.Types.JsCodeWithReturnToVarTemp;
					previous.value = val.values.splice(0,1)[0];
					modified = true;
					return;
				}
			}
			if(val.type == forth.Types.CommentLine || val.type == forth.Types.CommentParentheses) {
			} else if(val.type === forth.Types.ValueLocal && val.values.length == 0) {
			} else if(val.type === forth.Types.ValueLocalTemp && val.values.length == 0) {
			} else if(val.type === forth.Types.NumberToVar || val.type === forth.Types.StringToVar ||
				val.type === forth.Types.JsCodeWithReturnToVar ||
				val.type === forth.Types.NumberToVarTemp || val.type === forth.Types.StringToVarTemp ||
				val.type === forth.Types.JsCodeWithReturnToVarTemp
			) {
			} else if(val.type === forth.Types.Body) {
				previous = visitNodes(inlineValueLocalTemp, val, previous);
			} else {
				visitNodes(inlineValueLocalTemp, val);
				previous = val;
			}
		}
		return previous;
	}

	function rewriteJSCode(current, previous) {
		for (var i=0;i<current.length;++i) {
			var val = current[i];
			if(val.type === forth.Types.JsCode && previous !== null && previous !== undefined) {
				var match = /^[ ]*(.+)[ ]+=[ ]+stack\.pop\([ ]*\)[ ;]*$/.exec(val.body);
				if(match !== null) {
					if(previous.type === forth.Types.Number) {
						previous.type = forth.Types.NumberAssignToVar;
						previous.name = match[1];
						val.type = forth.Types.Empty;
						modified = true;
						return;
					} else if(previous.type === forth.Types.String) {
						previous.type = forth.Types.StringAssignToVar;
						previous.name = match[1];
						val.type = forth.Types.Empty;
						modified = true;
						return;
					} else if(previous.type === forth.Types.JsCodeWithReturn) {
						previous.type = forth.Types.JsCodeWithReturnAssignToVar;
						previous.value = match[1];
						val.type = forth.Types.Empty;
						modified = true;
						return;
					}
				} else {
					match = /^[ ]*(.+)[ ]+\+=[ ]+stack\.pop\([ ]*\)[ ;]*$/.exec(val.body);
					if(match !== null) {
						if(previous.type === forth.Types.Number) {
							previous.type = forth.Types.NumberAddToVar;
							previous.name = match[1];
							val.type = forth.Types.Empty;
							modified = true;
							return;
						} else if(previous.type === forth.Types.String) {
							previous.type = forth.Types.StringAddToVar;
							previous.name = match[1];
							val.type = forth.Types.Empty;
							modified = true;
							return;
						} else if(previous.type === forth.Types.JsCodeWithReturn) {
							previous.type = forth.Types.JsCodeWithReturnAddToVar;
							previous.value = match[1];
							val.type = forth.Types.Empty;
							modified = true;
							return;
						}
					} else {
						match = /^[ ]*return[ ]+stack\.pop\([ ]*\)[ ]*$/.exec(val.body);
						if(match !== null) {
							if(previous.type === forth.Types.Number) {
								previous.type = forth.Types.Empty;
								val.body = "return " + previous.value;
								modified = true;
								return;
							} else if(previous.type === forth.Types.String) {
								previous.type = forth.Types.Empty;
								val.body = "return \"" + previous.value + "\"";
								modified = true;
								return;
							} else if(previous.type === forth.Types.JsCodeWithReturn) {
								previous.type = forth.Types.Empty;
								val.body = "return " + previous.body;
								modified = true;
								return;
							}
						}
					}
				}
			}
			if(val.type == forth.Types.CommentLine || val.type == forth.Types.CommentParentheses) {
			} else if(val.type === forth.Types.ValueLocal && val.values.length == 0) {
			} else if(val.type === forth.Types.ValueLocalTemp && val.values.length == 0) {
			} else if(val.type === forth.Types.Body) {
				previous = visitNodes(rewriteJSCode, val, previous);
			} else {
				visitNodes(rewriteJSCode, val);
				previous = val;
			}
		}
		return previous;
	}

	function inlineValueLocalTempIntoJsOperators(current, previous) {
		for (var i=0;i<current.length;++i) {
			var val = current[i];
			if((val.type === forth.Types.JsCodeWithReturn ||
				val.type === forth.Types.JsCodeWithReturnAddToVar ||
				val.type === forth.Types.JsCodeWithReturnToVar ||
				val.type === forth.Types.JsCodeWithReturnToVarTemp ||
				val.type === forth.Types.JsCodeWithReturnAssignToVar
				) &&
				previous !== null && previous !== undefined) {
				var match = /^[ ]*(.+)[ ]+(.+)[ ]+(.+)[ ]*$/.exec(val.body);
				if(match !== null) {
					var previous_used = false;
					switch(previous.type) {
						case forth.Types.NumberToVarTemp:
							if(match[1] === previous.name) {
								match[1] = previous.value;
								previous_used = true;
							}
							if(match[3] === previous.name) {
								match[3] = previous.value;
								previous_used = true;
							}
							val.body = match[1] + " " + match[2] + " " + match[3];
							break;
						case forth.Types.StringToVarTemp:
							val.body = "";
							if(match[1] === previous.name) {
								val.body += "\"" + previous.value + "\"";
								previous_used = true;
							} else {
								val.body += match[1];
							}

							val.body += " " + match[2] + " ";

							if(match[3] === previous.name) {
								val.body += "\"" + previous.value + "\"";
								previous_used = true;
							} else {
								val.body += match[3];
							}
							break;
						case forth.Types.JsCodeWithReturnToVarTemp:
							if(match[1] === previous.value) {
								match[1] = previous.body;
								previous_used = true;
							}
							if(match[3] === previous.value) {
								match[3] = previous.body;
								previous_used = true;
							}
							val.body = match[1] + " " + match[2] + " " + match[3];
							break;
					}

					if(previous_used) {
						previous.type = forth.Types.Empty
						modified = true;
						return;
					}
				}
			}
			if(val.type == forth.Types.CommentLine || val.type == forth.Types.CommentParentheses) {
			} else if(val.type === forth.Types.ValueLocal && val.values.length == 0) {
			} else if(val.type === forth.Types.ValueLocalTemp && val.values.length == 0) {
			} else if(val.type === forth.Types.Body) {
				previous = visitNodes(inlineValueLocalTempIntoJsOperators, val, previous);
			} else {
				visitNodes(inlineValueLocalTempIntoJsOperators, val);
				previous = val;
			}
		}
		return previous;
	}

	do {
		modified = false;

		visitNodes(fixIncompleteDoLoops, code_tree);
		visitNodes(rewriteStackPop, code_tree);
		//visitNodes(inlineValueLocal, code_tree);
		//visitNodes(inlineValueLocalTemp, code_tree);
		visitNodes(rewriteJSCode, code_tree);
		visitNodes(inlineValueLocalTempIntoJsOperators, code_tree);
		visitNodes(removeEmptyCodeTreeEntries, code_tree);
	} while(modified);

	return code_tree;
};

forth.compile = function(code) {
	let tokens = forth.tokenize(code);
	//Filesystem.writeFileSync("generated-tokens.json", JSON.stringify(tokens, null, "\t"));
	let code_tree = forth.createFromForthTokens(tokens);
	//Filesystem.writeFileSync("generated-code_tree.json", JSON.stringify(code_tree, null, "\t"));
	let optimized_code_tree = forth.optimizeCodeTree(code_tree);
	//Filesystem.writeFileSync("optimized-code_tree.json", JSON.stringify(optimized_code_tree, null, "\t"));
	let generated_code = forth.generateJsCode(optimized_code_tree);
	//Filesystem.writeFileSync("generated-code.js", generated_code);
	return generated_code;
};

forth.compileWithContext = function(code, context) {
	let tokens = forth.tokenize(code);
	let code_tree = forth.createFromForthTokens(tokens, context);
	let optimized_code_tree = forth.optimizeCodeTree(code_tree);
	let generated_code = forth.generateJsCode(optimized_code_tree);
	return generated_code;
};

// allows embedding sforth into normal websites
forth.compileAllScriptRegions = function() {
	let nodes = document.querySelectorAll('script[type="application/sforth"]');

	function addToDOM(i, id, target_type, src) {
		let script = document.createElement("script");
		if(id)
			script.id = id;
		if(target_type)
			script.type = target_type;
		script.textContent = src;

		if(!!window.jQuery) {
			$(nodes[i]).replaceWith(script);
		} else {
			document.body.removeChild(nodes[i]);
			document.body.appendChild(script);
		}
	}

	function compileRegion(i, src, filenames, target_type, id, context) {
		if(filenames.length === 0 || (filenames.length == 1 && filenames[0] === "")) {
			if(nodes[i].textContent) { // src that is between <script ...> and </script>
				src += "\n" + forth.compileWithContext(nodes[i].textContent, context);
			}
			addToDOM(i, id, target_type, src);
			compileNode(i+1);
		} else {
			let xmlhttp = new XMLHttpRequest();
			xmlhttp.onreadystatechange = function() {
				if (xmlhttp.readyState === 4){
					if(xmlhttp.status == 200) {
						var ext = filenames[0].substr(filenames[0].length-2);
						if(ext == "js") {
							src += "\n" + xmlhttp.responseText;
						} else if(ext == "fs") {
							src += "\n" + forth.compileWithContext(xmlhttp.responseText, context);
						} else {
							console.log("Unknown file type " + filenames[0]);
						}
						compileRegion(i, src, filenames.slice(1), target_type, id, context);
					} else {
						// TODO: error?
						console.log("Couldn't load file " + filenames[0]);
					}
				}
			};

			xmlhttp.open('GET', filenames[0], true);
			xmlhttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');  // Tells server that this call is made for ajax purposes.
																			// Most libraries like jQuery/Prototype/Dojo do this
			xmlhttp.send(null);  // No data need to send along with the request.
		}
	}

	function compileNode(i) {
		if(i >= nodes.length) // Done
			return;

		let filenames = nodes[i].getAttribute("data-src") || "";
		let target_type = nodes[i].getAttribute("data-type");
		let id = nodes[i].getAttribute("data-id");
		let throw_on_underflow=nodes[i].getAttribute("data-throw-on-underflow");

		if(throw_on_underflow === null)
			throw_on_underflow = true;

		let src = "\"use strict\";\n";
		src += "var sforthThrowOnUnderflow=" + throw_on_underflow + ";";

		compileRegion(i, src, filenames.split(";"), target_type, id, {});
	}

	compileNode(0);
};

// auto compile the script nodes to javascript
if(typeof window != "undefined" && !!window.jQuery) {
	$( document ).ready(function() {
		forth.compileAllScriptRegions();
	});
}
